#' Execute surrogate minimal depth variable importance
#'
#' This function determines the surrogate minimal depth of variables from a forest that is created by getTreeranger, addLayer and getSurrogates functions.
#'
#' @param forest a list containing allvariables and trees. Allvariables is a vector of all variable names in the original data set (strings). Trees is a list of trees that was generated by getTreeranger, addLayer, and getSurrogates functions.
#' @param s.l Number of average surrogate variables in the respective layers. (use count.surrogate function to get it)
#' @return List with the following components:
#' \itemize{
#' \item depth: mean surrogate minimal depth for each variable
#' \item selected: variables has been selected (1) or not (0),
#' \item threshold: the threshold that is used for the selection
#' }
#' @export
surrmindep <- function(forest, s.l) {
  variables <- forest[["allvariables"]]
  trees <- forest[["trees"]]

  num.trees <- length(trees)
  var.num <- length(variables)

  # prepare matrix for mindepth
  mindepth <- matrix(NA, nrow = num.trees, ncol = var.num)
  colnames(mindepth) <- variables

  MAX.DEPTH <- 10000
  # maximal Depth of trees and the number of nodes in every layer is saved to calculate treshold in a following step
  maxdepth <- rep(NA, num.trees)
  nodesAtDepthMatrix <- matrix(NA, nrow = MAX.DEPTH, ncol = num.trees)
  # get mindepth for every variable in every tree
  for (i in 1:num.trees) {
    nodesAtDepth <- rep(NA, MAX.DEPTH)
    tree <- trees[[i]]
    # get layer information of the variables and save it in minimal depth file
    depth.tree <- rep(NA, length(variables))
    o <- 1
    while (anyNA(depth.tree) && o <= length(tree)) {
      node <- unlist(tree[o])
      if (node["status"] == 1) {
        if (is.na(depth.tree[node["splitvariable"]])) {
          depth.tree[as.numeric(node["splitvariable"])] <- as.numeric(node["layer"])
        }
        if (length(node) > 7) {
          for (r in 8:(7 + (length(node) - 7) / 2)) {
            if (is.na(depth.tree[as.numeric(node[r])])) {
              depth.tree[as.numeric(node[r])] <- as.numeric(node["layer"])
            }
          }
        }
      }
      o <- o + 1
    }
    # variables with no split in the tree get maxdepth as minimal depth
    depth.tree[which(is.na(depth.tree))] <- as.numeric(unlist(tree[length(tree)])["layer"])
    # save min and max depth information for every tree
    mindepth[i, ] <- depth.tree
    maxdepth[i] <- as.numeric(unlist(tree[length(tree)])["layer"])
    # find the number of nodes in every layer

    laystat <- cbind(sapply(tree, "[[", "layer"), sapply(tree, "[[", "status"))
    colnames(laystat) <- c("layer", "status")
    for (u in 1:(maxdepth[i])) {
      nodesAtDepth[u] <- nrow(subset(laystat, laystat[, "layer"] == u & laystat[, "status"] == 1))
    }
    nodesAtDepthMatrix[, i] <- nodesAtDepth
  }

  # create mean values for the minimal depth of different variables
  mean.depth <- colMeans(mindepth)

  # determine the mean depth of an uninformative variable similarly as in Ishwaran et. al. Journal of the American Statistical
  # Accociation 2010

  treeHeight <- maxdepth
  avgTreeHeight <- mean(treeHeight, na.rm = TRUE)
  maxTreeHeight <- max(treeHeight, na.rm = TRUE)

  # threshold has to be calculated different when trees are small
  if ((avgTreeHeight) < 2) {
    s.l.root <- s.l[1]
    p.root <- (s.l.root + 1) / var.num
    p.1 <- 1 - p.root
    threshold <- p.root * 0 + p.1 * 1
    warning("Trees are very small! Threshold is defined based on trees with only root nodes.")
  }

  if ((avgTreeHeight) >= 2) {
    nodes.at.depth.avg <- apply(nodesAtDepthMatrix, 1, mean, na.rm = TRUE)
    s.l.noroot <- s.l[-1]
    s.l.root <- s.l[1]
    p.root <- (s.l.root + 1) / var.num
    var.at.depth <- nodes.at.depth.avg[1:(avgTreeHeight - 1)] * (s.l.noroot[1:(avgTreeHeight - 1)] + 1) # 1 time for the original tree and s-times for
    # the surrogates
    #-1 since the last layer will be added later
    p.depth <- var.at.depth / var.num
    p.all <- c(p.root, p.depth)
    prob.sum <- 0
    probs.used <- NULL
    for (u in 1:length(p.all)) {
      p.u <- p.all[u]
      prob.sum <- prob.sum + p.u
      if (prob.sum >= 1) break
      probs.used[u] <- p.u
    }
    prob.last <- 1 - sum(probs.used) # the last layer (that was excluded before) is now used as minimal depth when the variable doesnt appear before
    probs.used <- c(probs.used, prob.last)
    layers <- c(0:(length(probs.used) - 1))
    threshold <- sum(layers * probs.used)
  }

  # Decide if variables are important or unimportant
  Importances <- rep(NA, var.num)
  for (p in 1:var.num) {
    if (mean.depth[p] < threshold) {
      Importances[p] <- 1
    } else {
      Importances[p] <- 0
    }
  }
  names(Importances) <- variables
  results <- list(depth = mean.depth, selected = Importances, threshold = threshold)
  return(results)
}
